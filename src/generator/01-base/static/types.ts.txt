// Filter properties
export type EqualityOperators = 'EQ' | 'NE';
export type ComparisonOperators = 'LT' | 'GT' | 'LE' | 'GE' | 'LIKE' | 'ILIKE' | 'NOT_LIKE' | 'NOT_ILIKE';
export type ArrayOperators = 'IN' | 'NOT_IN';
export type Operator = EqualityOperators | ComparisonOperators | ArrayOperators;

export type MapOperators<T> = { [K in EqualityOperators]?: T | null; } &
    { [K in ComparisonOperators]?: T; } &
    { [K in ArrayOperators]?: T[]; };

export type MainQueryFiler<T> = {
    [P in keyof T]?:
        T[P] extends Array<infer U> | undefined ? MainQueryFiler<U> :
            T[P] extends Record<any, any> | undefined ? MainQueryFiler<T[P]> : MapOperators<T[P]>;
};

export type QueryFilter<T> = MainQueryFiler<T> & {
    OR?: MainQueryFiler<T>[][];
};

export type Sort<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> | undefined ?
        Sort<U> : T[P] extends object | undefined ?
            Sort<T[P]> : 'asc' | 'desc';
};

// Select properties
export type QuerySelect<T> = {
    [P in keyof T]?:
        T[P] extends Array<infer U> | undefined ? (QuerySelect<U> | boolean) :
            T[P] extends Record<any, any> | undefined ? (QuerySelect<T[P]> | boolean) : boolean;
}

export type Select<T, Q extends QuerySelect<T>> = {

    // Filter out excluded properties beforehand
    [P in keyof T as Q[P] extends boolean ? P : Q[P] extends object ? P : never]:

    // Property
    Q[P] extends true ? T[P] :

        // Array
        T[P] extends Array<infer U> ? Select<U, Q[P] & QuerySelect<any>>[] :

            // Object
            T[P] extends Record<any, any> ? Select<T[P], Q[P] & QuerySelect<any>> : never
}

export type MapKeys<T, S extends Record<keyof T, string>> = {
    [K in keyof T as S[K]]: T[K];
};

export type CustomAttributeFilter =
    string | number | boolean |
    {id: string;} |
    {entityName: string; entityId: string;};

// Endpoint configurations
export type CountQuery<E> = {
    filter?: QueryFilter<E>;
};

export type Params<E> = {
    page?: number;
    pageSize?: number;
    sort?: Sort<E>[];
};

export type SomeQuery<
    E, // Entity
    I extends QuerySelect<any>, // Select for referenced entities
    S extends QuerySelect<any> // Select for entity properties
> = {
    include?: I;
    filter?: QueryFilter<E>;
    select?: S;
    params?: Params<E>;
    customAttributes?: Record<number, CustomAttributeFilter>;
};

export type SomeQueryReturn<
    E, // Entity
    R extends Record<string, any>, // Map of referenced-entity names to the type
    M extends Record<keyof Select<R, I>, string>, // Map of referenced-entity-id names to their entity name
    I extends QuerySelect<any>, // Select for referenced entities
    S extends QuerySelect<any> // Select for entity properties
> = {
    entities: Select<E, S>[];
    references: MapKeys<Select<R, I>, M>;
};

export type GenericQuery<P, B> = {
    params?: P;
    body?: B;
};

// Utils
const equality: string[] = ['EQ', 'NE'];
const simple: string[] = [...equality, 'LT', 'GT', 'LE', 'GE', 'LIKE', 'NOT_LIKE', 'ILIKE', 'NOT_ILIKE'];
const array: string[] = ['IN', 'NOT_IN'];
const filterMap: Record<Operator, string> = {
    EQ: 'eq',
    NE: 'ne',
    LT: 'lt',
    GT: 'gt',
    LE: 'le',
    GE: 'ge',
    LIKE: 'like',
    NOT_LIKE: 'notlike',
    ILIKE: 'ilike',
    NOT_ILIKE: 'notilike',
    IN: 'in',
    NOT_IN: 'notin'
};

const flattenFilter = (obj: QueryFilter<any> = {}): Record<string, string> => {
    const flatten = (obj: QueryFilter<any> = {}): [string, string][] => {
        const entries: [string, string][] = [];

        for (const [prop, propValue] of Object.entries(obj)) {

            if (prop === 'OR' && Array.isArray(propValue)) {
                for (let i = 0; i < propValue.length; i++) {
                    for (const or of propValue[i]) {
                        entries.push(
                            ...flatten(or)
                                .map(v => [`or${i || ''}-${v[0]}`, v[1]]) as [string, string][]
                        );
                    }
                }

                continue;
            }

            for (const [filter, value] of Object.entries(propValue as object)) {

                if (value === undefined) {
                    continue;
                }

                if (simple.includes(filter)) {
                    if (value === null && equality.includes(filter)) {
                        entries.push([`${prop}-${filter === 'EQ' ? 'null' : 'notnull'}`, '']);
                    } else {
                        entries.push([`${prop}-${filterMap[filter as Operator]}`, value]);
                    }
                } else if (array.includes(filter)) {
                    entries.push([
                        `${prop}-${filterMap[filter as Operator]}`,
                        `[${value.map((v: string | number) => typeof v === 'string' ? `"${v}"` : v)}]`
                    ]);
                } else {
                    entries.push(
                        ...flatten(propValue as QueryFilter<any>)
                            .map(v => [`${prop}.${v[0]}`, v[1]]) as [string, string][]
                    );
                    break;
                }
            }
        }

        return entries;
    };

    return Object.fromEntries(flatten(obj));
};

const flattenCustomAttributes = (obj: Record<number, CustomAttributeFilter> = {}): Record<string, string> => {
    const entries: [string, string][] = [];

    for (const [id, filter] of Object.entries(obj)) {
        const key = `customAttribute${id}`;

        if (typeof filter === 'object') {
            for (const [prop, value] of Object.entries(filter)) {
                entries.push([`${key}.${prop}-eq`, String(value)]);
            }
        } else {
            entries.push([`${key}-eq`, String(filter)]);
        }
    }

    return Object.fromEntries(entries);
};

const flattenSelect = (obj: Select<any, any> = {}): string[] => {
    const entries: string[] = [];

    for (const [prop, value] of Object.entries(obj)) {
        if (typeof value === 'object' && value) {
            entries.push(...flattenSelect(value).map(v => `${prop}.${v}`));
        } else if (value) {
            entries.push(prop);
        }
    }

    return entries;
};

export const flattenSort = (obj: Sort<any>[] = []): {sort: string} => {
    const flatten = (obj: Sort<any>, base = ''): string | undefined => {
        const [key, value] = Object.entries(obj ?? {})[0] ?? [];

        if (key && value) {
            const path = base + key;

            if (typeof value === 'object') {
                return flatten(value, path ? `${path}.` : '');
            } else if (['asc', 'desc'].includes(value)) {
                return `${value === 'desc' ? '-' : ''}${path}`;
            }
        }

        return undefined;
    };

    return {sort: obj.map(v => flatten(v)).filter(Boolean).join(',')};
};
